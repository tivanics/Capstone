library(survival)
library(tidyverse)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(lubridate)
library(survminer)
library(msm)
library(haven)
library(ggsci)
library(plotly)
library(scales)
options(scipen = 999)
# options(max.print = 20000)


# Load model objects

HCC.msm <- readRDS(file = "data/HCC.msm.rds")
HCC.preop <- readRDS(file = "data/HCC.preop.rds")
HCC.postop <- readRDS(file = "data/HCC.postop.rds")

# This function is borrowed from: https://www.r-bloggers.com/2016/07/round-values-while-preserve-their-rounded-sum-in-r/
# It rounds a list of numbers while preserving their overall sum, to a 
# user-specified number of digits

round_preserve_sum <- function(x, digits = 0) {
  up <- 10 ^ digits
  x <- x * up
  y <- floor(x)
  indices <- tail(order(x-y), round(sum(x)) - sum(y))
  y[indices] <- y[indices] + 1
  y / up
}

# This function takes the multistate object (HCC.msm) and gives the 
# output of estimates at step = 3 (3 month intervals) up to 60 (60 months)
pmatrix_calculator <- function(input, steps=3, last=60){
  timepoints <- c(seq(from=0, to=last, by=steps))
  abc <- NULL
  for(i in 1:(last / steps + 1)) {
    abc <- cbind(abc, pmatrix.msm(input, t = timepoints[i]))
  }
  return(abc)}

pmatrix_calculatorpreop <- function(input, sex, age, steps=3, last=60){
  timepoints <- c(seq(from=0, to=last, by=steps))
  abc <- NULL
  for(i in 1:(last / steps + 1)) {
    abc <-
      cbind(abc, pmatrix.msm(
        input,
        covariates = list(GenderMale1female0 = sex, Age = age),
        t = timepoints[i]
      ))
  }
  
  return(abc)
}

pmatrix_calculatorpostop <- function(input, sex, age, solitary, 
                                     satellite, microvascular, size, 
                                     steps=3, last=60) {
  timepoints <- c(seq(from = 0, to = last, by = steps))
  abc <- NULL
  for (i in 1:(last / steps + 1)) {
    abc <-
      cbind(abc, pmatrix.msm(
        input,
        covariates = list(
          GenderMale1female0 = sex,
          Age = age,
          Path_number_solitary = solitary,
          Satellite_lesion_path = satellite,
          Microvascular_invasionnotabletobeassessedindeterminate9 = microvascular,
          Path_size_5cm = size
        ),
        t = timepoints[i]
      ))
  }
  
  return(abc)
}

# by default, the plot generated by preparePlot() is the baseline model for
# the postsurgery state
preparePlot <- function(input = "base", state = "Surgery", 
                        sex = "Female", age = 18, solitary = 0, 
                        satellite = "No", microvascular = 0, size = 0, 
                        steps = 3, last = 60, by_year=FALSE) {
  series <- data.frame(
    Months = as.numeric(rep(seq(0, last, by = steps), each = 8)),
    Probability = pmatrix_calculator(HCC.msm, steps, last)[state, ],
    State <- rep(c("No recurrence", "1st local recurrence", "2nd local recurrence", 
                "3rd local recurrence","4th local recurrence",
                "5th local recurrence","Distant recurrence", "Death"), 21)
  )
  
  if(input == "preop") {
    series$Probability <- pmatrix_calculatorpreop(HCC.preop, sex, age,
                                                  steps, last)[state,]
    series$Probability <- round_preserve_sum(series$Probability, digits = 5)
  }
  
  else if(input == "postop") {
    series$Probability <- pmatrix_calculatorpostop(HCC.postop, sex, age, solitary, 
                                                   satellite, microvascular, size, 
                                                   steps, last)[state,]
    series$Probability <- round_preserve_sum(series$Probability, digits = 5)
  }
  
  # # debugging in console
  # print(series$Probability[0:20])
  
  series$State <-
    factor(
      series$State,
      levels =  c("No recurrence", "1st local recurrence", "2nd local recurrence", 
                  "3rd local recurrence","4th local recurrence",
                  "5th local recurrence","Distant recurrence", "Death")
    )
  
  if(input == "postop"){
    print("in filter condition")
    print(state)

    if(state == "First local recurrence") {
      series <- dplyr::filter(series, State != "No recurrence")
      print(head(series))
    }

    else if(state == "Second local recurrence") {
      series <- dplyr::filter(series,
                              State != "1st local recurrence" &
                                State != "No recurrence")
      
      print(head(series))
    }
  }
  
  # series$Probability <- round(series$Probability, digits = 3)
  
  # Colour scale consistency:
  colourLevels <-  c("No recurrence", "1st local recurrence", "2nd local recurrence",
              "3rd local recurrence","4th local recurrence",
              "5th local recurrence","Distant recurrence", "Death")
  myColours <- get_palette(palette = "Reds", 9)
  # myColours <- myColours[2:9] # first colour too similar to last colour
  names(myColours) <- colourLevels
  # print(myColours)
  # colScale <- scale_fill_manual(name = "grp", values = myColours)

  if(!by_year) {
    seriesPlot <-
      ggplot(series, aes(Months, Probability),
             cex.axis = 3.0) +
      geom_area(aes(fill = State)) + 
      scale_x_continuous(limits = c(0, 60), expand = c(0, 1)) +
      scale_y_continuous(labels = scales::percent) +
      coord_cartesian(xlim = c(0, 60), ylim = c(0, 1), expand = F) +
      theme_bw() +
      scale_fill_manual(values = myColours, drop = FALSE) +  
      theme(
        panel.grid = element_blank(),
        panel.border = element_blank(),
        text = element_text(size = 14),
        legend.title = element_blank(),
        axis.title=element_text(size = 14, face = "bold")
      )
  }
  else if(by_year){
    series <- dplyr::filter(series, (Months %% 12) == 0)
    series$Years <- series$Months / 12
    series$Probability <- round_preserve_sum(series$Probability, digits = 5)
    seriesPlot <-
      ggplot(series, aes(Years, Probability), 
             cex.axis = 3.0) +
             
      geom_area(aes(fill = State)) +
      scale_x_continuous(limits = c(0, 5), expand = c(0, 1)) +
      scale_y_continuous(labels = scales::percent) +
      coord_cartesian(xlim = c(0, 5), ylim = c(0, 1), expand = F) + 
      theme_bw() + 
      scale_fill_manual(values = myColours, drop = FALSE) + 
      theme(
        panel.grid = element_blank(),
        panel.border = element_blank(),
        text = element_text(size = 14),
        legend.title = element_blank(),
        axis.title=element_text(size = 14, face = "bold")
      )
  }
  
  seriesPlotly <- ggplotly(seriesPlot) %>%
                    layout(legend = list(
                      font = list(size = 14),
                      title = list(text = '<b>State</b>',
                                   font = list(size = 16))
                    )) %>%
                    layout(xaxis = list(fixedrange = TRUE)) %>%
                    layout(yaxis = list(fixedrange = TRUE))
  
  return(seriesPlotly)
  
}

# This is an example of time interval 3 (3 months) for multistate model object HCC.postop, 
# with covariates inputted (this is an example of what the user would input into the calculator)
# I.e. I want estimates for a patient who had multiple tumors, was age 60, was a female, 
# had satellite lesions, greater than 5 cm tumor, and microvascular invasion.
# pmatrix_calculatorpostop(
#   HCC.postop,
#   gender = "Female",
#   age = 60,
#   satellite = "Yes",
#   solitary = 1,
#   microvascular = 1,
#   size = 1,
#   last = 60
# )

#This is what would be specified by the user
#Path_number_solitary: 1 = multiple tumour, 0 = solitary tumor
#Age: continuous
#Gender: "Male" = Male, "Female" = Female
#Satellite_lesion_path: "Yes" = Yes, "No" = No
#Microvascular_invasionnotabletobeassessedindeterminate9: 1=microvascular invasion, 0=no microvascular invasion
#Path_size_5cm 0=less than 5 cm, 1=5 cm or greater

