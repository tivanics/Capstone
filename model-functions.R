library(survival)
library(tidyverse)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(lubridate)
library(survminer)
library(msm)
library(haven)
library(ggsci)
library(plotly)
library(scales)
options(scipen = 999)

# Load model objects
#Baseline (no covariates)
#HCC.msm <- readRDS(file = "data/HCC.msm.rds")
#Preop (sex, age)
HCC.preop <- readRDS(file = "data/HCC.preop.rds")
#Postop (age, sex, pathology variables including microvascular invasion, satellite lesion, tumor number tumor size)
HCC.postop <- readRDS(file = "data/HCC.postop.rds")

# This function is from: https://www.r-bloggers.com/2016/07/round-values-while-preserve-their-rounded-sum-in-r/
# The function preserves the overall sum and rounds the number to a specified number of digits

round_preserve_sum <- function(x, digits = 0) {
  up <- 10 ^ digits
  x <- x * up
  y <- floor(x)
  indices <- tail(order(x-y), round(sum(x)) - sum(y))
  y[indices] <- y[indices] + 1
  y / up
}

pmatrix_calculatorpreop <- function(input,
                                    sex,
                                    age,
                                    steps=3, last=60){
  timepoints <- c(seq(from=0, to=last, by=steps))
  probestimates <- NULL
  for(i in 1:(last / steps + 1)) {
    probestimates <-
      cbind(probestimates, pmatrix.msm(
        input,
        covariates = list(GenderMale1female0 = sex, Age = age),
        t = timepoints[i]
      ))
  }
  return(probestimates)
}

pmatrix_calculatorpostop <- function(input, 
                                     sex,
                                     age,
                                     solitary, 
                                     satellite,
                                     microvascular,
                                     size, 
                                     steps=3, last=60) {
  timepoints <- c(seq(from = 0, to = last, by = steps))
  probestimates <- NULL
  for (i in 1:(last / steps + 1)) {
    probestimates <-
      cbind(probestimates, pmatrix.msm(
        input,
        covariates = list(
          GenderMale1female0 = sex,
          Age = age,
          Path_number_solitary = solitary,
          Satellite_lesion_path = satellite,
          Microvascular_invasionnotabletobeassessedindeterminate9 = microvascular,
          Path_size_5cm = size
        ),
        t = timepoints[i]
      ))
  }
  return(probestimates)
}

# by default, the plot generated by preparePlot() is the baseline model for
# the postsurgery state
preparePlot <- function(input = "preop", state = "Surgery", 
                        sex = "Female", age = 18, solitary = 0, 
                        satellite = "No", microvascular = 0, size = 0, 
                        steps = 3, last = 60, by_year=FALSE) {
  series <- data.frame(
    Months = as.numeric(rep(seq(0, last, by = steps), each = 8)),
    Probability = pmatrix_calculatorpreop(HCC.msm, steps, last)[state, ],
    State <- rep(c("No recurrence", "1st intra-hepatic recurrence", "2nd intra-hepatic recurrence", 
                "3rd intra-hepatic recurrence","4th intra-hepatic recurrence",
                "5th intra-hepatic recurrence","Distant recurrence", "Death"), 21)
  )
  
    if(input == "postop") {
    series$Probability <- pmatrix_calculatorpostop(HCC.postop, 
                                                   sex,
                                                   age,
                                                   solitary, 
                                                   satellite,
                                                   microvascular,
                                                   size, 
                                                   steps, last)[state,]
    series$Probability <- round_preserve_sum(series$Probability, digits = 4)
  }
  
  series$State <-
    factor(
      series$State,
      levels =  c("No recurrence", "1st intra-hepatic recurrence", "2nd intra-hepatic recurrence", 
                  "3rd intra-hepatic recurrence","4th intra-hepatic recurrence",
                  "5th intra-hepatic recurrence","Distant recurrence", "Death")
    )
  
  if(input == "postop"){
    print("in filter condition")
    print(state)

    if(state == "First local recurrence") {
      series <- dplyr::filter(series, State != "No recurrence")
      print(head(series))
    }

    else if(state == "Second local recurrence") {
      series <- dplyr::filter(series,
                              State != "1st intra-hepatic recurrence" &
                                State != "No recurrence")
      
      print(head(series))
    }
  }
  
  # Colour scale consistency:
  colourLevels <-  c("No recurrence", "1st intra-hepatic recurrence", "2nd intra-hepatic recurrence",
              "3rd intra-hepatic recurrence","4th intra-hepatic recurrence",
              "5th intra-hepatic recurrence","Distant recurrence", "Death")
  myColours <- get_palette(palette = "Reds", 9)
  names(myColours) <- colourLevels

#Create the plot
    seriesPlot <-
      ggplot(series, aes(Months, Probability),
             cex.axis = 3.0) +
      geom_area(aes(fill = State)) + 
      scale_x_continuous(limits = c(0, 60), expand = c(0, 1)) +
      scale_y_continuous(labels = scales::percent) +
      coord_cartesian(xlim = c(0, 60), ylim = c(0, 1), expand = F) +
      theme_bw() +
      scale_fill_manual(values = myColours, drop = FALSE) +  
      theme(
        panel.grid = element_blank(),
        panel.border = element_blank(),
        text = element_text(size = 14),
        legend.title = element_blank(),
        axis.title=element_text(size = 14, face = "bold")
      )

  
  seriesPlotly <- ggplotly(seriesPlot) %>%
                    layout(legend = list(
                      font = list(size = 14),
                      title = list(text = '<b>State</b>',
                                   font = list(size = 16))
                    )) %>%
                    layout(xaxis = list(fixedrange = TRUE)) %>%
                    layout(yaxis = list(fixedrange = TRUE))
  
  return(seriesPlotly)
  
}



